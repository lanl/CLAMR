.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parallel::ForkManager 3"
.TH Parallel::ForkManager 3 "2012-12-24" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parallel::ForkManager \- A simple parallel processing fork manager
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Parallel::ForkManager;
\&
\&  $pm = Parallel::ForkManager\->new($MAX_PROCESSES);
\&
\&  foreach $data (@all_data) {
\&    # Forks and returns the pid for the child:
\&    my $pid = $pm\->start and next;
\&
\&    ... do some work with $data in the child process ...
\&
\&    $pm\->finish; # Terminates the child process
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is intended for use in operations that can be done in parallel
where the number of processes to be forked off should be limited. Typical
use is a downloader which will be retrieving hundreds/thousands of files.
.PP
The code for a downloader would look something like this:
.PP
.Vb 2
\&  use LWP::Simple;
\&  use Parallel::ForkManager;
\&
\&  ...
\&
\&  @links=(
\&    ["http://www.foo.bar/rulez.data","rulez_data.txt"],
\&    ["http://new.host/more_data.doc","more_data.doc"],
\&    ...
\&  );
\&
\&  ...
\&
\&  # Max 30 processes for parallel download
\&  my $pm = Parallel::ForkManager\->new(30);
\&
\&  foreach my $linkarray (@links) {
\&    $pm\->start and next; # do the fork
\&
\&    my ($link,$fn) = @$linkarray;
\&    warn "Cannot get $fn from $link"
\&      if getstore($link,$fn) != RC_OK;
\&
\&    $pm\->finish; # do the exit in the child process
\&  }
\&  $pm\->wait_all_children;
.Ve
.PP
First you need to instantiate the ForkManager with the \*(L"new\*(R" constructor.
You must specify the maximum number of processes to be created. If you
specify 0, then \s-1NO\s0 fork will be done; this is good for debugging purposes.
.PP
Next, use \f(CW$pm\fR\->start to do the fork. \f(CW$pm\fR returns 0 for the child process,
and child pid for the parent process (see also \*(L"\fIfork()\fR\*(R" in \fIperlfunc\fR\|(1p)).
The \*(L"and next\*(R" skips the internal loop in the parent process. \s-1NOTE:\s0
\&\f(CW$pm\fR\->start dies if the fork fails.
.PP
\&\f(CW$pm\fR\->finish terminates the child process (assuming a fork was done in the
\&\*(L"start\*(R").
.PP
\&\s-1NOTE:\s0 You cannot use \f(CW$pm\fR\->start if you are already in the child process.
If you want to manage another set of subprocesses in the child process,
you must instantiate another Parallel::ForkManager object!
.SH "METHODS"
.IX Header "METHODS"
The comment letter indicates where the method should be run. P for parent,
C for child.
.ie n .IP "new $processes [, $tempdir]  # P" 5
.el .IP "new \f(CW$processes\fR [, \f(CW$tempdir\fR]  # P" 5
.IX Item "new $processes [, $tempdir]  # P"
Instantiate a new Parallel::ForkManager object. You must specify the maximum
number of children to fork off. If you specify 0 (zero), then no children
will be forked. This is intended for debugging purposes.
.Sp
The optional second parameter, \f(CW$tempdir\fR, is only used if you want the
children to send back a reference to some data (see \s-1RETRIEVING\s0 \s-1DATASTRUCTURES\s0
below). If not provided, it is set to $\fIFile::Temp::tempdir()\fR.
.Sp
The new method will die if the temporary directory does not exist or it is not
a directory, whether you provided this parameter or the
$\*(L"\fIFile::Temp::tempdir()\fR is used.\*(R"
.ie n .IP "start [ $process_identifier ]  # P" 5
.el .IP "start [ \f(CW$process_identifier\fR ]  # P" 5
.IX Item "start [ $process_identifier ]  # P"
This method does the fork. It returns the pid of the child process for
the parent, and 0 for the child process. If the \f(CW$processes\fR parameter
for the constructor is 0 then, assuming you're in the child process,
\&\f(CW$pm\fR\->start simply returns 0.
.Sp
An optional \f(CW$process_identifier\fR can be provided to this method... It is used by
the \*(L"run_on_finish\*(R" callback (see \s-1CALLBACKS\s0) for identifying the finished
process.
.ie n .IP "finish [ $exit_code [, $data_structure_reference] ]  # C" 5
.el .IP "finish [ \f(CW$exit_code\fR [, \f(CW$data_structure_reference\fR] ]  # C" 5
.IX Item "finish [ $exit_code [, $data_structure_reference] ]  # C"
Closes the child process by exiting and accepts an optional exit code
(default exit code is 0) which can be retrieved in the parent via callback.
If the second optional parameter is provided, the child attempts to send
it's contents back to the parent. If you use the program in debug mode
($processes == 0), this method just calls the callback.
.Sp
If the \f(CW$data_structure_reference\fR is provided, then it is serialized and
passed to the parent process. See \s-1RETRIEVING\s0 \s-1DATASTRUCTURES\s0 for more info.
.ie n .IP "set_max_procs $processes  # P" 5
.el .IP "set_max_procs \f(CW$processes\fR  # P" 5
.IX Item "set_max_procs $processes  # P"
Allows you to set a new maximum number of children to maintain.
.IP "wait_all_children  # P" 5
.IX Item "wait_all_children  # P"
You can call this method to wait for all the processes which have been
forked. This is a blocking wait.
.SH "CALLBACKS"
.IX Header "CALLBACKS"
You can define callbacks in the code, which are called on events like starting
a process or upon finish. Declare these before the first call to \fIstart()\fR.
.PP
The callbacks can be defined with the following methods:
.ie n .IP "run_on_finish $code [, $pid ]  # P" 4
.el .IP "run_on_finish \f(CW$code\fR [, \f(CW$pid\fR ]  # P" 4
.IX Item "run_on_finish $code [, $pid ]  # P"
You can define a subroutine which is called when a child is terminated. It is
called in the parent process.
.Sp
The paremeters of the \f(CW$code\fR are the following:
.Sp
.Vb 6
\&  \- pid of the process, which is terminated
\&  \- exit code of the program
\&  \- identification of the process (if provided in the "start" method)
\&  \- exit signal (0\-127: signal name)
\&  \- core dump (1 if there was core dump at exit)
\&  \- datastructure reference or undef (see RETRIEVING DATASTRUCTURES)
.Ve
.ie n .IP "run_on_start $code  # P" 4
.el .IP "run_on_start \f(CW$code\fR  # P" 4
.IX Item "run_on_start $code  # P"
You can define a subroutine which is called when a child is started. It called
after the successful startup of a child in the parent process.
.Sp
The parameters of the \f(CW$code\fR are the following:
.Sp
.Vb 2
\&  \- pid of the process which has been started
\&  \- identification of the process (if provided in the "start" method)
.Ve
.ie n .IP "run_on_wait $code, [$period]  # P" 4
.el .IP "run_on_wait \f(CW$code\fR, [$period]  # P" 4
.IX Item "run_on_wait $code, [$period]  # P"
You can define a subroutine which is called when the child process needs to wait
for the startup. If \f(CW$period\fR is not defined, then one call is done per
child. If \f(CW$period\fR is defined, then \f(CW$code\fR is called periodically and the
module waits for \f(CW$period\fR seconds betwen the two calls. Note, \f(CW$period\fR can be
fractional number also. The exact \*(L"$period seconds\*(R" is not guarranteed,
signals can shorten and the process scheduler can make it longer (on busy
systems).
.Sp
The \f(CW$code\fR called in the \*(L"start\*(R" and the \*(L"wait_all_children\*(R" method also.
.Sp
No parameters are passed to the \f(CW$code\fR on the call.
.SH "RETRIEVING DATASTRUCTURES from child processes"
.IX Header "RETRIEVING DATASTRUCTURES from child processes"
The ability for the parent to retrieve data structures is new as of version
0.7.6.
.PP
Each child process may optionally send 1 data structure back to the parent.
By data structure, we mean a reference to a string, hash or array. The
contents of the data structure are written out to temporary files on disc
using the Storable modules' \fIstore()\fR method. The reference is then
retrieved from within the code you send to the run_on_finish callback.
.PP
The data structure can be any scalar perl data structure which makes sense:
string, numeric value or a reference to an array, hash or object.
.PP
There are 2 steps involved in retrieving data structures:
.PP
1) A reference to the data structure the child wishes to send back to the
parent is provided as the second argument to the \fIfinish()\fR call. It is up
to the child to decide whether or not to send anything back to the parent.
.PP
2) The data structure reference is retrieved using the callback provided in
the \fIrun_on_finish()\fR method.
.PP
Keep in mind that data structure retrieval is not the same as returning a
data structure from a method call. That is not what actually occurs. The
data structure referenced in a given child process is serialized and
written out to a file by Storable. The file is subsequently read back
into memory and a new data structure belonging to the parent process is
created. Please consider the performance penality it can imply, so try to
keep the returned structure small.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Parallel get"
.IX Subsection "Parallel get"
This small example can be used to get URLs in parallel.
.PP
.Vb 10
\&  use Parallel::ForkManager;
\&  use LWP::Simple;
\&  my $pm= Parallel::ForkManager\->new(10);
\&  for my $link (@ARGV) {
\&    $pm\->start and next;
\&    my ($fn)= $link =~ /^.*\e/(.*?)$/;
\&    if (!$fn) {
\&      warn "Cannot determine filename from $fn\en";
\&    } else {
\&      $0.=" ".$fn;
\&      print "Getting $fn from $link\en";
\&      my $rc=getstore($link,$fn);
\&      print "$link downloaded. response code: $rc\en";
\&    };
\&    $pm\->finish;
\&  };
.Ve
.SS "Callbacks"
.IX Subsection "Callbacks"
Example of a program using callbacks to get child exit codes:
.PP
.Vb 2
\&  use strict;
\&  use Parallel::ForkManager;
\&
\&  my $max_procs = 5;
\&  my @names = qw( Fred Jim Lily Steve Jessica Bob Dave Christine Rico Sara );
\&  # hash to resolve PID\*(Aqs back to child specific information
\&
\&  my $pm = Parallel::ForkManager\->new($max_procs);
\&
\&  # Setup a callback for when a child finishes up so we can
\&  # get it\*(Aqs exit code
\&  $pm\->run_on_finish( sub {
\&      my ($pid, $exit_code, $ident) = @_;
\&      print "** $ident just got out of the pool ".
\&        "with PID $pid and exit code: $exit_code\en";
\&  });
\&
\&  $pm\->run_on_start( sub {
\&      my ($pid,$ident)=@_;
\&      print "** $ident started, pid: $pid\en";
\&  });
\&
\&  $pm\->run_on_wait( sub {
\&      print "** Have to wait for one children ...\en"
\&    },
\&    0.5
\&  );
\&
\&  foreach my $child ( 0 .. $#names ) {
\&    my $pid = $pm\->start($names[$child]) and next;
\&
\&    # This code is the child process
\&    print "This is $names[$child], Child number $child\en";
\&    sleep ( 2 * $child );
\&    print "$names[$child], Child $child is about to get out...\en";
\&    sleep 1;
\&    $pm\->finish($child); # pass an exit code to finish
\&  }
\&
\&  print "Waiting for Children...\en";
\&  $pm\->wait_all_children;
\&  print "Everybody is out of the pool!\en";
.Ve
.SS "Data structure retrieval"
.IX Subsection "Data structure retrieval"
In this simple example, each child sends back a string reference.
.PP
.Vb 2
\&  use Parallel::ForkManager 0.7.6;
\&  use strict;
\&  
\&  my $pm = Parallel::ForkManager\->new(2, \*(Aq/server/path/to/temp/dir/\*(Aq);
\&  
\&  # data structure retrieval and handling
\&  $pm \-> run_on_finish ( # called BEFORE the first call to start()
\&    sub {
\&      my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_structure_reference) = @_;
\&  
\&      # retrieve data structure from child
\&      if (defined($data_structure_reference)) {  # children are not forced to send anything
\&        my $string = ${$data_structure_reference};  # child passed a string reference
\&        print "$string\en";
\&      } else {  # problems occuring during storage or retrieval will throw a warning
\&        print qq|No message received from child process $pid!\en|;
\&      }
\&    }
\&  );
\&  
\&  # prep random statement components
\&  my @foods = (\*(Aqchocolate\*(Aq, \*(Aqice cream\*(Aq, \*(Aqpeanut butter\*(Aq, \*(Aqpickles\*(Aq, \*(Aqpizza\*(Aq, \*(Aqbacon\*(Aq, \*(Aqpancakes\*(Aq, \*(Aqspaghetti\*(Aq, \*(Aqcookies\*(Aq);
\&  my @preferences = (\*(Aqloves\*(Aq, q|can\*(Aqt stand|, \*(Aqalways wants more\*(Aq, \*(Aqwill walk 100 miles for\*(Aq, \*(Aqonly eats\*(Aq, \*(Aqwould starve rather than eat\*(Aq);
\&  
\&  # run the parallel processes
\&  my $person = \*(Aq\*(Aq;
\&  foreach $person (qw(Fred Wilma Ernie Bert Lucy Ethel Curly Moe Larry)) {
\&    $pm\->start() and next;
\&  
\&    # generate a random statement about food preferences
\&    my $statement = $person . \*(Aq \*(Aq . $preferences[int(rand @preferences)] . \*(Aq \*(Aq . $foods[int(rand @foods)];
\&  
\&    # send it back to the parent process
\&    $pm\->finish(0, \e$statement);  # note that it\*(Aqs a scalar REFERENCE, not the scalar itself
\&  }
\&  $pm\->wait_all_children;
.Ve
.PP
A second datastructure retrieval example demonstrates how children decide
whether or not to send anything back, what to send and how the parent should
process whatever is retrieved.
.PP
.Vb 3
\&  use Parallel::ForkManager 0.7.6;
\&  use Data::Dumper;  # to display the data structures retrieved.
\&  use strict;
\&  
\&  my $pm = Parallel::ForkManager\->new(20);  # using the system temp dir $L<File::Temp::tempdir()
\&  
\&  # data structure retrieval and handling
\&  my %retrieved_responses = ();  # for collecting responses
\&  $pm \-> run_on_finish (
\&    sub {
\&      my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_structure_reference) = @_;
\&  
\&      # see what the child sent us, if anything
\&      if (defined($data_structure_reference)) {  # test rather than assume child sent anything
\&        my $reftype = ref($data_structure_reference);
\&        print qq|ident "$ident" returned a "$reftype" reference.\en\en|;
\&        if (1) {  # simple on/off switch to display the contents
\&          print &Dumper($data_structure_reference) . qq|end of "$ident" sent structure\en\en|;
\&        }
\&        
\&        # we can also collect retrieved data structures for processing after all children have exited
\&        $retrieved_responses{$ident} = $data_structure_reference;
\&      } else {
\&        print qq|ident "$ident" did not send anything.\en\en|;  
\&      }
\&    }
\&  );
\&  
\&  # generate a list of instructions
\&  my @instructions = (  # a unique identifier and what the child process should send
\&    {\*(Aqname\*(Aq => \*(Aq%ENV keys as a string\*(Aq, \*(Aqsend\*(Aq => \*(Aqkeys\*(Aq},
\&    {\*(Aqname\*(Aq => \*(AqSend Nothing\*(Aq},  # not instructing the child to send anything back to the parent
\&    {\*(Aqname\*(Aq => \*(AqChilds %ENV\*(Aq, \*(Aqsend\*(Aq => \*(Aqall\*(Aq},
\&    {\*(Aqname\*(Aq => \*(AqChild chooses randomly\*(Aq, \*(Aqsend\*(Aq => \*(Aqrandom\*(Aq},
\&    {\*(Aqname\*(Aq => \*(AqInvalid send instructions\*(Aq, \*(Aqsend\*(Aq => \*(AqNa Na Nana Na\*(Aq},
\&    {\*(Aqname\*(Aq => \*(AqENV values in an array\*(Aq, \*(Aqsend\*(Aq => \*(Aqvalues\*(Aq},
\&  );
\&  
\&  my $instruction = \*(Aq\*(Aq;
\&  foreach $instruction (@instructions) {
\&    $pm\->start($instruction\->{\*(Aqname\*(Aq}) and next;  # this time we are using an explicit, unique child process identifier
\&  
\&    # last step in child processing
\&    $pm\->finish(0) unless $instruction\->{\*(Aqsend\*(Aq};  # no data structure is sent unless this child is told what to send.
\&    
\&    if ($instruction\->{\*(Aqsend\*(Aq} eq \*(Aqkeys\*(Aq) {
\&      $pm\->finish(0, \ejoin(\*(Aq, \*(Aq, keys %ENV));
\&      
\&    } elsif ($instruction\->{\*(Aqsend\*(Aq} eq \*(Aqvalues\*(Aq) {
\&      $pm\->finish(0, [values %ENV]);  # kinda useless without knowing which keys they belong to...
\&      
\&    } elsif ($instruction\->{\*(Aqsend\*(Aq} eq \*(Aqall\*(Aq) {
\&      $pm\->finish(0, \e%ENV);  # remember, we are not "returning" anything, just copying the hash to disc
\&    
\&    # demonstrate clearly that the child determines what type of reference to send
\&    } elsif ($instruction\->{\*(Aqsend\*(Aq} eq \*(Aqrandom\*(Aq) {
\&      my $string = q|I\*(Aqm just a string.|;
\&      my @array = qw(I am an array);
\&      my %hash = (type => \*(Aqassociative array\*(Aq, synonym => \*(Aqhash\*(Aq, cool => \*(Aqvery :)\*(Aq);
\&      my $return_choice = (\*(Aqstring\*(Aq, \*(Aqarray\*(Aq, \*(Aqhash\*(Aq)[int(rand 3)];  # randomly choose return data type
\&      $pm\->finish(0, \e$string) if ($return_choice eq \*(Aqstring\*(Aq);
\&      $pm\->finish(0, \e@array) if ($return_choice eq \*(Aqarray\*(Aq);
\&      $pm\->finish(0, \e%hash) if ($return_choice eq \*(Aqhash\*(Aq);
\&      
\&    # as a responsible child, inform parent that their instruction was invalid
\&    } else {  
\&      $pm\->finish(0, \eqq|Invalid instructions: "$instruction\->{\*(Aqsend\*(Aq}".|);  # ordinarily I wouldn\*(Aqt include invalid input in a response...
\&    }
\&  }
\&  $pm\->wait_all_children;  # blocks until all forked processes have exited
\&  
\&  # post fork processing of returned data structures
\&  for (sort keys %retrieved_responses) {
\&    print qq|Post processing "$_"...\en|;
\&  }
.Ve
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
Do not use Parallel::ForkManager in an environment, where other child
processes can affect the run of the main program, so using this module
is not recommended in an environment where \fIfork()\fR / \fIwait()\fR is already used.
.PP
If you want to use more than one copies of the Parallel::ForkManager, then
you have to make sure that all children processes are terminated, before you
use the second object in the main program.
.PP
You are free to use a new copy of Parallel::ForkManager in the child
processes, although I don't think it makes sense.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2000\-2010 Szabo\*', Bala\*'zs (dLux)
.PP
All right reserved. This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\&  dLux (Szabo\*', Bala\*'zs) <dlux@dlux.hu>
.Ve
.SH "CREDITS"
.IX Header "CREDITS"
.Vb 5
\&  Noah Robin <sitz@onastick.net> (documentation tweaks)
\&  Chuck Hirstius <chirstius@megapathdsl.net> (callback exit status, example)
\&  Grant Hopwood <hopwoodg@valero.com> (win32 port)
\&  Mark Southern <mark_southern@merck.com> (bugfix)
\&  Ken Clarke <www.perlprogrammer.net>  (datastructure retrieval)
.Ve
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 84:" 4
.IX Item "Around line 84:"
Unterminated L<...> sequence
.IP "Around line 88:" 4
.IX Item "Around line 88:"
Unterminated L<...> sequence
